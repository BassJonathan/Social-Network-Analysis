---
title: "Assignment Social Network Analysis"
output: pdf_document
---

```{r setup, include=FALSE}
# Verändere Titel, Namen & Datum in dem Yaml header am Beginn des files!

# Globale Chunk Optionen:
knitr::opts_chunk$set(echo = TRUE)

# Loading / Installing packages depending on whether it is already installed.
uP <- function(...) {
  x <- list(...)
  for(p in x) {
    if (!is.element(p, installed.packages()[,1])) {install.packages(p,dep = TRUE, repos = "http://cran.wu.ac.at")}
    library(p, character.only = TRUE)}
}
uP('tidyverse', 'tidygraph', 'ggraph', 'tidylog')
```

<!-- Bitte Meta Infos anpassen -->

| __Meta Infos__  |                                            |    
|-----------------|--------------------------------------------|
| Student:in      | Jonathan Baß                               |
| Titel           | Hier könnte der Titel ihrer Arbeit stehen! |
| Kurskontext     | Social Network Analysis                    |
| Datum           | insertdate                                 |
| Dozent          | Philipp M. Mendoza, M.Sc.                  |
<!-- Hilfe für Tabellen: https://www.tablesgenerator.com/latex_tables -->
Für weitere Anleitungen und Tipps siehe den [Syllabus](https://pmmendoza.notion.site/Syllabus-2021-c93a917f658649df854dd3035358cb73) und den [Eintrag zur Portfolioprüfung](https://pmmendoza.notion.site/Portfoliopr-fung-ein-paar-Tipps-2d5b6d52e1784006b22021d6dbe0b377).  

Wichtig: das ganze sollte in der Form eines Blogpostes geschrieben sein; sprich ein Fließtext!
Nachfolgend ein Vorschlag der Strukturierung eurer Arbeit; in jedem Report sollten *zumindest* die hier angeführten Punkte abgedeckt werden.

## Executive Summary 
_Dies ist die einzige Sektzion die in Bullet points angeführt werden soll._
* Einleitung
* Forschungsfrage
* Datensatz
* Strategie
* Ergebnisse

## Einleitung und Fragestellung
Die Analyse und Nachverfolgung von Kontaktdaten ist in der Medizin und Forschung schon lange ein wichtiges Thema, momentan durch die aktuelle Corona-Pandemie jedoch relevanter als je zuvor. Bei engen oder langen Kontaken können Keime und Erreger zwischen den Personen ausgetauscht werden und sich Krankheiten auf diesem Weg verbreiten. Dies stellt im Alltag kein großes Problem dar, da die meisten Erreger harmlos sind und das menschliche Immunsystem den Ausbruch der Krankheit verhindern kann. Dies ist jedoch in Krankenhäusern nicht immer der Fall. Durch die hohe Konzentration an angewendeten Medikamenten wie Antibiotika können sich schnell multiressistente Keime bilden, welche auch Krankenhauskeime genannt werden. Eine detaillierte Beschreibung und Quantifizierung der Kontakte in Krankenhäusern kann deshalb wichtige Informationen für die Epidemiologie von Krankenhausinfektionen sowie für die Konzeption und Validierung von Kontrollmaßnahmen liefern. Wie diese Vorgenommen werden und welche Schlüsse aus der Analyse gezogen werden können wir in dem folgenden Beitrag erläutert.

### Thema
In der geriatrigerschen Abteilung eines Krankenhauses in Lyon, Frankreich wurde 2010 ein Experiment gemacht. Dafür wurden allen sich auf der Station befindlichen Personen mit tragbare RFID (Radio Frequency Identification) Sensoren ausgerüstet. Diese haben alle Interaktionen im Nahbereich von etwa 1,5m und einer zeitlichen Auflösung von 20 Sekunden über einem Zeitraum von vier Tagen und vier Nächten gemessen. Die Studie umfasste 46 Mitarbeiter des Gesundheitswesens und 29 Patienten und es wurden insgesamt 14.037 Kontakte erfasst.

### Daten
Die Daten liegen als ein igraph graph-Objekt vor, welches die graph-Attribute "name" und "Citation", als vertex-Attribut "Status" und als edge-Attribut "Time" besitzt. "Status" beschreibt dabei die Rolle der Person. Dabei wird in Verwaltungspersonal (*ADM*), Ärzte (*MED*), medizinisches Personal wie Krankenschwestern und -pleger oder Hilfspersonal (*NUR*) und Patienten/Patientinnen (*PAT*) unterschieden. "Time" ist der Zeitstempel der Sekunde, an dem das 20-Sekunden Intervall ausgelaufen und nicht erneuert wurde.

### Forschungsfrage
Die Übertragung von Krankheiten kann unter anderem durch persönlichen Kontakt übertragen werden. Personen, die viele Kontakte mit einer Vielzahl an Personen haben, können dabei als Superspreader fungieren und Krankheiten schnell verteilen. **In der folgenden Ausarbeitung beschäftige ich mich mit der Frage, ob gewisse Rollen in Krankenhäusern ein höheres Risiko haben solch ein Superspreader zu sein und ob die durch organisatorische und räumlich gegebene Bildung von Gemeinschaften einen Einfluss auf eine mögliche Verbereitung hat.**

### Relevanz der Forschungsfrage
Die Kontaktnachverfolgung ist durch die aktuelle Corona-Pandemie ein wichtigeres Thema denn je. Es gilt geschwächte und anfällige Personen zu schützen. Gerade in Krankenhäusern kann eine unkontrollierte Ausrbeitung des SarsCov2-Viruses durch einen Superspreader verherende Auswirkungen haben. Die Analyse und Beantwortung der Forschungsfrage kann bei der Entwicklung eines Schutzkonzeptes helfen und das allgemeine Risiko einer Ansteckung während eines Krankenhausaufenthaltes verringern.

## Analysestrategie  
Um die Forschungsfrage korrekt und vollständig beantworten zu können, reicht es nicht aus die reinen Verbindungen zu zählen. Sollte zum Beispiel ein Patient viel Kontakt mit anderen (infizierten) Patienten haben, würde dadurch keine Übertragung und damit auch keine Ausbreitung der Krankheit erfolgen. Aus diesem Grund muss man die Rollen der einzelnen Personen bei der Bewertung des Kontaktes berücksichtigen. Dafür können zwei Werte für jede Node berechnen: Der "Within-community Degree"-Wert (deutsch: Innergemeinschaftlicher Grad) beschreibt die Vernetzung innerhalb der eigenen Community. Dazu wird der "Participation Coefficient" (deutsch: Teilnahmekoeffizient) betrachtet. Dieser beschreibt die Vernetzung einer Person über die Grenzen der eigenen Community heraus. Für jede Node können beide Werte berechnet und auf einem Diagramm als Punkte ausgeplottet werden. Sollte zum Beispiel eine Person eine sehr gute Vernetzung innerhalb der eigenen Community, aber auch zu anderen Communites haben, ist das Risiko bei einer Infektion als Superspreader zu fungierten stark erhöht. Für die Berechnung dieser Schlüselwerte wird der Algorithmus "rnetcarto" verwendet. Rnectcarto bietet schnelle Netzwerkmodularität und Rollenberechnung durch simuliertes Annealing.
* Operationalisierung eurer Forschungsfrage (welche Maße verwendet ihr um eure Forschungsfrage zu beantworten und warum?)

???
* Charakterisierung des Netzwerks


* Kontext der verwendeten Daten
Anzahl nodes and edges
## Umsetzung  

### Datenmanipulationen

### Erklärung der Schritte
Die folgende Auflistung beschreibt die einzelnen Schritte, welche für die Auswertung verwendet wurden.Diese könnnen chronologisch ausgeführt werden, um das gleiche Ergebniss zu erhalten.

### 1. Pakete installieren
Zu Beginn müssen alle benötigten Pakete installiert werden. Darunter befinden sich unter anderem "igraphdata", aus welchem wir die Daten laden, standart-Pakete wie "ggraph". Zudem benötigen wir den oben erwähnten Annealing-Algorithmus "rnetcarto".
```{r}
# install.packages("igraph", dependencies = T)
# install.packages("igraphdata", dependencies = T)
# install.packages("tidygraph", dependencies = T)
# install.packages("tidyverse", dependencies = T)
# install.packages("ggraph", dependencies = T)
# install.packages("ggthemes", dependencies = TRUE) # a collection of a lot of themes for dataviz!
# install.packages("gganimate", dependencies = TRUE) # an dynamic animation package
# install.packages("gifski", dependencies = TRUE) # an engine to render gifs
# install.packages("rnetcarto", dependencies = TRUE)
```



### 2. Bibliotheken deklarieren
Die im letzen Schritt installierten Pakete werden nun als Bibliotheken deklariert.
```{r message=FALSE}
library(igraph)
library(igraphdata)

library(ggraph)
library(ggthemes)
library(gganimate)
library(gifski)

library(tidyverse)
library(tidygraph)

library(RColorBrewer)
library(rnetcarto)
```

### 3. Alte Daten aus dem Environment enfernen
Damit keine Konflikte mit alten Daten auftreten, und die Berechnungen möglichst perfomant laufen können, werden alle alten Daten aus dem Environment gelöscht.
```{r}
rm(list = ls())
```

### 4. Daten von igraphdata instanziieren
Nun instanziieren wir die Daten mit dem folgenden Befehl. Es existiert nun ein igraph graph-Objekt "rfid", welches die benötigten Daten beinhaltet. Dieses Objekt bildet die Grunlage für die folgenden Berechnungen.
```{r}
data("rfid")
```

### 5. Schleifen und direktionale Beziehungen entfernen und in Variable speichern
In Schritt 5 werden die direktionalen Beziehungen und Schleifen entfernt und durch undirektionale ersetzt.
```{r}
df <- as.undirected(simplify(rfid))
```

### 6. igraph-Objekt in adjacency matrix convertieren
```{r}
df.mat=as_adjacency_matrix(df, sparse = F)
head(df.mat, 1)
```

### 7. Simulierter annealing Algorithmus
```{r}
rnc=netcarto(df.mat)
rnc
```

### 8. Neues igraph-Objekt mit Index als Spalte erstellen
```{r}
df %>% as_tbl_graph() %>% activate(nodes) %>% mutate(name = row_number()) -> df2
df2
```

### 9. Status mergen
```{r}
test <- merge(x = df2 , y = rnc[[1]], by = "name", all = TRUE)
head(test, 10)
```

### 10. Plot
```{r warning=FALSE}
ggplot(test, aes(y = connectivity, x = participation)) + 
  geom_point(aes(color=Status, shape=role, size=module))
```

### Interpretation der Visualisierungen 

## Conclusio  

### Wiederholung der Fragestellung
### Zusammenfassung der zentralen Ergebnisse
#### (_Limitationen, weiterführende Kommentare, etc._)


<!-- ## Install packages -->
<!-- ```{r} -->
<!-- # install.packages("igraph", dependencies = T) -->
<!-- # install.packages("igraphdata", dependencies = T) -->
<!-- # install.packages("tidygraph", dependencies = T) -->
<!-- # install.packages("tidyverse", dependencies = T) -->
<!-- # install.packages("ggraph", dependencies = T) -->
<!-- # install.packages("ggthemes", dependencies = TRUE) # a collection of a lot of themes for dataviz! -->
<!-- # install.packages("gganimate", dependencies = TRUE) # an dynamic animation package -->
<!-- # install.packages("gifski", dependencies = TRUE) # an engine to render gifs -->
<!-- # install.packages("rnetcarto", dependencies = TRUE) -->
<!-- ``` -->

<!-- ## Setup libraries -->
<!-- ```{r} -->
<!-- library(igraph) -->
<!-- library(igraphdata) -->

<!-- library(ggraph) -->
<!-- library(ggthemes) -->
<!-- library(gganimate) -->
<!-- library(gifski) -->

<!-- library(tidyverse) -->
<!-- library(tidygraph) -->

<!-- library(RColorBrewer) -->
<!-- library(rnetcarto) -->
<!-- ``` -->


<!-- ## Remove old data -->
<!-- ```{r} -->
<!-- rm(list = ls()) -->
<!-- ``` -->


<!-- ## Initialize data -->
<!-- ```{r} -->
<!-- data("rfid") -->
<!-- #rfid -->
<!-- ``` -->


<!-- ## Remove loops as well as directional data and store as dataframe -->
<!-- ```{r} -->
<!-- df <- as.undirected(simplify(rfid)) -->
<!-- #df -->
<!-- ``` -->

<!-- ## Identify roles -->
<!-- ```{r} -->
<!-- df.mat=as_adjacency_matrix(df, sparse = F) -->
<!-- head(df.mat, 1) -->
<!-- ``` -->

<!-- ## Add professions from dataframe -->
<!-- ```{r} -->
<!-- rnc=netcarto(df.mat) -->
<!-- rnc -->
<!-- ``` -->

<!-- ## Number of modules -->
<!-- ```{r} -->
<!-- df %>% as_tbl_graph() %>% activate(nodes) %>% mutate(name = row_number()) -> klm -->
<!-- klm -->
<!-- ``` -->

<!-- ## Plot -->
<!-- ```{r} -->
<!-- test <- merge(x = klm , y = rnc[[1]], by = "name", all = TRUE) -->
<!-- head(test, 10) -->
<!-- ``` -->

<!-- ## Plot -->
<!-- ```{r warning=FALSE} -->
<!-- ggplot(test, aes(y = connectivity, x = participation)) +  -->
<!--   geom_point(aes(color=Status, shape=role, size=module)) -->
<!-- ``` -->