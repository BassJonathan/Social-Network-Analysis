---
title: "Assignment Social Network Analysis"
output: pdf_document
---

```{r setup, include=FALSE}
# Verändere Titel, Namen & Datum in dem Yaml header am Beginn des files!

# Globale Chunk Optionen:
knitr::opts_chunk$set(echo = TRUE)

# Loading / Installing packages depending on whether it is already installed.
uP <- function(...) {
  x <- list(...)
  for(p in x) {
    if (!is.element(p, installed.packages()[,1])) {install.packages(p,dep = TRUE, repos = "http://cran.wu.ac.at")}
    library(p, character.only = TRUE)}
}
uP('tidyverse', 'tidygraph', 'ggraph', 'tidylog')
```

<!-- Bitte Meta Infos anpassen -->

| __Meta Infos__  |                                            |    
|-----------------|--------------------------------------------|
| Student:in      | Jonathan Baß                               |
| Titel           | Hier könnte der Titel ihrer Arbeit stehen! |
| Kurskontext     | Social Network Analysis                    |
| Datum           | insertdate                                 |
| Dozent          | Philipp M. Mendoza, M.Sc.                  |
<!-- Hilfe für Tabellen: https://www.tablesgenerator.com/latex_tables -->
Für weitere Anleitungen und Tipps siehe den [Syllabus](https://pmmendoza.notion.site/Syllabus-2021-c93a917f658649df854dd3035358cb73) und den [Eintrag zur Portfolioprüfung](https://pmmendoza.notion.site/Portfoliopr-fung-ein-paar-Tipps-2d5b6d52e1784006b22021d6dbe0b377).  

Wichtig: das ganze sollte in der Form eines Blogpostes geschrieben sein; sprich ein Fließtext!
Nachfolgend ein Vorschlag der Strukturierung eurer Arbeit; in jedem Report sollten *zumindest* die hier angeführten Punkte abgedeckt werden.

## Executive Summary 
_Dies ist die einzige Sektzion die in Bullet points angeführt werden soll._
* Einleitung
* Forschungsfrage
* Datensatz
* Strategie
* Ergebnisse

## Einleitung und Fragestellung
Die Analyse und Nachverfolgung von Kontaktdaten ist in der Medizin und Forschung schon lange ein wichtiges Thema, momentan durch die aktuelle Corona-Pandemie jedoch relevanter als je zuvor. Bei engen oder langen Kontaken können Keime und Erreger zwischen den Personen ausgetauscht werden und sich Krankheiten auf diesem Weg verbreiten. Dies stellt im Alltag kein großes Problem dar, da die meisten Erreger harmlos sind und das menschliche Immunsystem den Ausbruch der Krankheit verhindern kann. Dies ist jedoch in Krankenhäusern nicht immer der Fall. Durch die hohe Konzentration an angewendeten Medikamenten wie Antibiotika können sich schnell multiressistente Keime bilden, welche auch Krankenhauskeime genannt werden. Eine detaillierte Beschreibung und Quantifizierung der Kontakte in Krankenhäusern kann deshalb wichtige Informationen für die Epidemiologie von Krankenhausinfektionen sowie für die Konzeption und Validierung von Kontrollmaßnahmen liefern. Wie diese Vorgenommen werden und welche Schlüsse aus der Analyse gezogen werden können wir in dem folgenden Beitrag erläutert.

### Thema
In der geriatrigerschen Abteilung eines Krankenhauses in Lyon, Frankreich wurde 2010 ein Experiment gemacht. Dafür wurden allen sich auf der Station befindlichen Personen mit tragbare RFID (Radio Frequency Identification) Sensoren ausgerüstet. Diese haben alle Interaktionen im Nahbereich von etwa 1,5m und einer zeitlichen Auflösung von 20 Sekunden über einem Zeitraum von vier Tagen und vier Nächten gemessen. Die Studie umfasste 46 Mitarbeiter des Gesundheitswesens und 29 Patienten und es wurden insgesamt 14.037 Kontakte erfasst.

### Daten
Die Daten liegen als ein igraph graph-Objekt vor, welches die graph-Attribute "name" und "Citation", als vertex-Attribut "Status" und als edge-Attribut "Time" besitzt. "Status" beschreibt dabei die Rolle der Person. Dabei wird in Verwaltungspersonal (*ADM*), Ärzte (*MED*), medizinisches Personal wie Krankenschwestern und -pleger oder Hilfspersonal (*NUR*) und Patienten/Patientinnen (*PAT*) unterschieden. "Time" ist der Zeitstempel der Sekunde, an dem das 20-Sekunden Intervall ausgelaufen und nicht erneuert wurde.

### Forschungsfrage
Die Übertragung von Krankheiten kann unter anderem durch persönlichen Kontakt übertragen werden. Personen, die viele Kontakte mit einer Vielzahl an Personen haben, können dabei als Superspreader fungieren und Krankheiten schnell verteilen. **In der folgenden Ausarbeitung beschäftige ich mich mit der Frage, ob gewisse Rollen in Krankenhäusern ein höheres Risiko haben solch ein Superspreader zu sein und ob die durch organisatorische und räumlich gegebene Bildung von Gemeinschaften einen Einfluss auf eine mögliche Verbereitung hat.**

### Relevanz der Forschungsfrage
Die Kontaktnachverfolgung ist durch die aktuelle Corona-Pandemie ein wichtigeres Thema denn je. Es gilt geschwächte und anfällige Personen zu schützen. Gerade in Krankenhäusern kann eine unkontrollierte Ausrbeitung des SarsCov2-Viruses durch einen Superspreader verherende Auswirkungen haben. Die Analyse und Beantwortung der Forschungsfrage kann bei der Entwicklung eines Schutzkonzeptes helfen und das allgemeine Risiko einer Ansteckung während eines Krankenhausaufenthaltes verringern.

## Analysestrategie  
Um die Forschungsfrage korrekt und vollständig beantworten zu können, reicht es nicht aus die reinen Verbindungen zu zählen. Sollte zum Beispiel ein Patient viel Kontakt mit anderen (infizierten) Patienten haben, würde dadurch keine Übertragung und damit auch keine Ausbreitung der Krankheit erfolgen. Aus diesem Grund muss man die Rollen der einzelnen Personen bei der Bewertung des Kontaktes berücksichtigen. Dafür können zwei Werte für jede Node berechnen: Der "Within-community Degree"-Wert (deutsch: Innergemeinschaftlicher Grad) beschreibt die Vernetzung innerhalb der eigenen Community. Dazu wird der "Participation Coefficient" (deutsch: Teilnahmekoeffizient) betrachtet. Dieser beschreibt die Vernetzung einer Person über die Grenzen der eigenen Community heraus. Für jede Node können beide Werte berechnet und auf einem Diagramm als Punkte ausgeplottet werden. Sollte zum Beispiel eine Person eine sehr gute Vernetzung innerhalb der eigenen Community, aber auch zu anderen Communites haben, ist das Risiko bei einer Infektion als Superspreader zu fungierten stark erhöht. Für die Berechnung dieser Schlüselwerte wird der Algorithmus "Netcarto" verwendet. Rnectcarto bietet schnelle Netzwerkmodularität und Rollenberechnung durch simuliertes Annealing.
* Operationalisierung eurer Forschungsfrage (welche Maße verwendet ihr um eure Forschungsfrage zu beantworten und warum?)

???
* Charakterisierung des Netzwerks


* Kontext der verwendeten Daten
Anzahl nodes and edges
## Umsetzung  

### Datenmanipulationen

### Erklärung der Schritte
Die folgende Auflistung beschreibt die einzelnen Schritte, welche für die Auswertung verwendet wurden.Diese könnnen chronologisch ausgeführt werden, um das gleiche Ergebniss zu erhalten.

### 1. Pakete installieren
Zu Beginn müssen alle benötigten Pakete installiert werden. Darunter befinden sich unter anderem "igraphdata", aus welchem wir die Daten laden, standart-Pakete wie "ggraph". Zudem benötigen wir den oben erwähnten Annealing-Algorithmus "rnetcarto".
```{r}
# install.packages("igraph", dependencies = T)
# install.packages("igraphdata", dependencies = T)
# install.packages("tidygraph", dependencies = T)
# install.packages("tidyverse", dependencies = T)
# install.packages("ggraph", dependencies = T)
# install.packages("ggthemes", dependencies = TRUE) # a collection of a lot of themes for dataviz!
# install.packages("gganimate", dependencies = TRUE) # an dynamic animation package
# install.packages("gifski", dependencies = TRUE) # an engine to render gifs
# install.packages("rnetcarto", dependencies = TRUE)
```



### 2. Bibliotheken deklarieren
Die im letzen Schritt installierten Pakete werden nun als Bibliotheken deklariert.
```{r message=FALSE}
library(igraph)
library(igraphdata)

library(ggraph)
library(ggthemes)
library(gganimate)
library(gifski)

library(tidyverse)
library(tidygraph)

library(RColorBrewer)
library(rnetcarto)
```

### 3. Alte Daten aus dem Environment enfernen
Damit keine Konflikte mit alten Daten auftreten, und die Berechnungen möglichst perfomant laufen können, werden alle alten Daten aus dem Environment gelöscht.
```{r}
rm(list = ls())
```

### 4. Daten von igraphdata instanziieren
Nun instanziieren wir die Daten mit dem folgenden Befehl. Es existiert nun ein igraph graph-Objekt "rfid", welches die benötigten Daten beinhaltet. Dieses Objekt bildet die Grunlage für die folgenden Berechnungen.
```{r}
data("rfid")
```

### 5. Schleifen und direktionale Beziehungen entfernen und in Variable speichern
In Schritt 5 werden Schleifen entfernt und direktionale Beziehungen in inderktionale Beziehungen aufgelöst. Dadurch werden Fehler in der Darstellung vermieden.
```{r}
df <- as.undirected(simplify(rfid))
```

### 6. igraph-Objekt in adjacency matrix convertieren
Damit der Netrcarto-Algorithmus die Daten verarbeiten kann müssen diese als Adjazenzmatrix vorliegen. Der folgende Befehl konvertiert das Dateframe in dieses Format legt die neue Matrix als Vairiation der Variable df.
```{r}
df.mat=as_adjacency_matrix(df, sparse = F)
head(df.mat, 1)
```

### 7. Simulierter annealing Algorithmus
Nun kann der Netcarto-Algorithmus angewandt werden. Dieser symuliert ein sogenanntes "annealing" oder auf Deutsch "abkühlen", und sich auf die Art und Weiße bezieht, wie die einzelnen Communities entstehen. Eine gute Analogie ist das Abkühlen von Metall, nachdem es zum glühen gebracht wurden. Zu diesem Zeitpunkt bewegen sich die einzelnen Atome noch sehr schnell - erkennbar an der Hitze- und Lichtemision. Im verlauf des Abkühlprozesses ordnen sich die Atome in einer kristallinen Form an und es wird ein nahezu optimaler Zustand erreicht. Zieht man nun die Verbindungen zu dem Algorithmus würde so wird das Netzwerk in einen ähnlichen Zustand gebracht und es können einzelne Module mit einer Wahrscheinlichkeit von bis zu 90% berechnet werden.
```{r}
rnc=netcarto(df.mat)
rnc
```

### 8. Neues igraph-Objekt mit Index als Spalte erstellen
Uns liegt nun ein Dataframe mit den zu Beginn definierten Werten vor, welche auf das Modul und die Rolle beinhalten. Leider ist jedoch beim Erstellen der Adjacency-Matrix die Rolle verloren gegangen, da es sich bei der Spalte nicht um nummerische Werte handelt. Daher müssen wir die beiden Dataframes vereinen. Dafür fügen wir dem neu erstellten Dataframe eine Spalte mit dem Index hinzu, um im nächsten Schritt einen merge durchführen zu können. Da diese bei dem ursprünglichen DF "name" heißt, verwenden wir hier die gleiche Bezeichnung.
```{r}
df %>% as_tbl_graph() %>% activate(nodes) %>% mutate(name = row_number()) -> df2
df2
```

### 9. Status mergen
Durch das Hinzufügen der Index-Spalte im vorherigen Schritt können wir nun einen Merge durchführen. Dabei verwenden wir den Index, welcher als "name" in der urpsünglichen Tabelle enthalten war. Nun haben wir ein Dataframe mit allen benötigten Werten, welche für die Auswertung relevant sind.
```{r}
test <- merge(x = df2 , y = rnc[[1]], by = "name", all = TRUE)
head(test, 10)
```

### 10. Plot
Der letzte Schritt ist das Plotten mit ggplot. Als y-Werte verwenden wir dem "Within-community Degree", also den Wert, welcher die Vernetzung innerhalb der eigenen Community darstellt. Auf der x-Achse begindet sich
"Participation Coefficient", bzw. die Vernetzung zu anderen Communities. Der Algorithmus unterscheidet dabei in verschiedene Rollen. Menschen, die weder eine hohe Vernetzung innerhalb ihrer Community noch außerhalb haben werden als 
```{r warning=FALSE}
ggplot(test, aes(y = Within-community-Degree, x = Participation-Coefficient)) + 
  geom_point(aes(color=Status, shape=role, size=module))
```

### Interpretation der Visualisierungen 

## Conclusio  

### Wiederholung der Fragestellung
### Zusammenfassung der zentralen Ergebnisse
#### (_Limitationen, weiterführende Kommentare, etc._)


<!-- ## Install packages -->
<!-- ```{r} -->
<!-- # install.packages("igraph", dependencies = T) -->
<!-- # install.packages("igraphdata", dependencies = T) -->
<!-- # install.packages("tidygraph", dependencies = T) -->
<!-- # install.packages("tidyverse", dependencies = T) -->
<!-- # install.packages("ggraph", dependencies = T) -->
<!-- # install.packages("ggthemes", dependencies = TRUE) # a collection of a lot of themes for dataviz! -->
<!-- # install.packages("gganimate", dependencies = TRUE) # an dynamic animation package -->
<!-- # install.packages("gifski", dependencies = TRUE) # an engine to render gifs -->
<!-- # install.packages("rnetcarto", dependencies = TRUE) -->
<!-- ``` -->

<!-- ## Setup libraries -->
<!-- ```{r} -->
<!-- library(igraph) -->
<!-- library(igraphdata) -->

<!-- library(ggraph) -->
<!-- library(ggthemes) -->
<!-- library(gganimate) -->
<!-- library(gifski) -->

<!-- library(tidyverse) -->
<!-- library(tidygraph) -->

<!-- library(RColorBrewer) -->
<!-- library(rnetcarto) -->
<!-- ``` -->


<!-- ## Remove old data -->
<!-- ```{r} -->
<!-- rm(list = ls()) -->
<!-- ``` -->


<!-- ## Initialize data -->
<!-- ```{r} -->
<!-- data("rfid") -->
<!-- #rfid -->
<!-- ``` -->


<!-- ## Remove loops as well as directional data and store as dataframe -->
<!-- ```{r} -->
<!-- df <- as.undirected(simplify(rfid)) -->
<!-- #df -->
<!-- ``` -->

<!-- ## Identify roles -->
<!-- ```{r} -->
<!-- df.mat=as_adjacency_matrix(df, sparse = F) -->
<!-- head(df.mat, 1) -->
<!-- ``` -->

<!-- ## Add professions from dataframe -->
<!-- ```{r} -->
<!-- rnc=netcarto(df.mat) -->
<!-- rnc -->
<!-- ``` -->

<!-- ## Number of modules -->
<!-- ```{r} -->
<!-- df %>% as_tbl_graph() %>% activate(nodes) %>% mutate(name = row_number()) -> klm -->
<!-- klm -->
<!-- ``` -->

<!-- ## Plot -->
<!-- ```{r} -->
<!-- test <- merge(x = klm , y = rnc[[1]], by = "name", all = TRUE) -->
<!-- head(test, 10) -->
<!-- ``` -->

<!-- ## Plot -->
<!-- ```{r warning=FALSE} -->
<!-- ggplot(test, aes(y = connectivity, x = participation)) +  -->
<!--   geom_point(aes(color=Status, shape=role, size=module)) -->
<!-- ``` -->